//! Stellarcade Number Guess Contract
//!
//! Players pick a secret number within a chosen range [`min`, `max`] and wager
//! tokens on their guess.  The actual secret is generated by the Random
//! Generator contract's request/fulfill model, ensuring neither the house nor
//! any observer can bias the outcome after the player's guess is locked in.
//!
//! ## Game Flow
//! 1. Player calls `start_game` → range + wager locked, RNG requested, tokens
//!    transferred from player to this contract.
//! 2. Player calls `submit_guess` → guess committed on-chain while RNG is still
//!    pending.  Auth required so only the player can set their own guess.
//! 3. Oracle fulfills randomness on the RNG contract (off-chain step).
//! 4. Anyone calls `resolve_game` → reads RNG result, derives secret number,
//!    settles payout if guess matches.
//!
//! ## Fairness Model
//! The player's guess is committed to storage **before** the oracle reveals the
//! server seed, so the oracle cannot select a seed after observing the guess.
//! After resolution, anyone can independently verify:
//!   `sha256(server_seed || game_id_be)[0..8] % range_size + min == secret`
//! using the seed stored by the RNG contract.
//!
//! ## Payout
//! A winning player receives their full wager back plus a multiplier equal to
//! `range_size - 1` times the wager, minus a configurable house edge in basis
//! points:
//!   `gross_payout = wager * range_size`
//!   `fee          = gross_payout * house_edge_bps / 10_000`
//!   `net_payout   = gross_payout - fee`
//!
//! ## Storage Strategy
//! - `instance()`: Admin, RngContract, PrizePoolContract, BalanceContract,
//!   MinWager, MaxWager, HouseEdgeBps.  Fixed-size contract config.
//! - `persistent()`: one `Game` entry per `game_id`, TTL bumped on every write.
#![no_std]
#![allow(unexpected_cfgs)]
// `init` intentionally takes many arguments to configure the contract in one
// atomic call; the lint also fires on macro-generated client stubs.
#![allow(clippy::too_many_arguments)]

use soroban_sdk::{
    contract, contracterror, contractevent, contractimpl, contracttype, token::TokenClient,
    Address, Env,
};

use stellarcade_random_generator::RandomGeneratorClient;

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/// Persistent storage TTL in ledgers (~30 days at 5 s/ledger).
pub const PERSISTENT_BUMP_LEDGERS: u32 = 518_400;

const BASIS_POINTS_DIVISOR: i128 = 10_000;

/// Maximum allowed range size (`max - min + 1`).
/// Caps the multiplier to prevent i128 overflow when computing gross_payout
/// even for the platform's maximum token supply.
pub const MAX_RANGE_SIZE: u32 = 1_000_000;

// ---------------------------------------------------------------------------
// Error Types
// ---------------------------------------------------------------------------

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    AlreadyInitialized = 1,
    NotInitialized = 2,
    NotAuthorized = 3,
    InvalidAmount = 4,
    /// `min >= max` or `range_size > MAX_RANGE_SIZE`.
    InvalidRange = 5,
    GameAlreadyExists = 6,
    GameNotFound = 7,
    /// `submit_guess` called twice for the same game.
    AlreadyGuessed = 8,
    /// `submit_guess` requires the game to be in the Open state.
    GameNotOpen = 9,
    /// `resolve_game` requires a guess to have been submitted.
    GuessNotSubmitted = 10,
    GameAlreadyResolved = 11,
    RngNotFulfilled = 12,
    /// Guess falls outside the declared `[min, max]` range.
    GuessOutOfRange = 13,
    WagerTooLow = 14,
    WagerTooHigh = 15,
    Overflow = 16,
}

// ---------------------------------------------------------------------------
// Storage Types
// ---------------------------------------------------------------------------

/// Per-game lifecycle state.
///
/// `Open`     — `start_game` called; waiting for player to submit a guess.
/// `Guessed`  — `submit_guess` called; waiting for RNG fulfillment and resolution.
/// `Won`      — Resolved; guess matched the secret number.
/// `Lost`     — Resolved; guess did not match.
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum GameStatus {
    Open = 0,
    Guessed = 1,
    Won = 2,
    Lost = 3,
}

/// Full state for a single number-guess game.
#[contracttype]
#[derive(Clone, Debug)]
pub struct Game {
    pub player: Address,
    /// Inclusive lower bound of the guessing range.
    pub min: u32,
    /// Inclusive upper bound of the guessing range.
    pub max: u32,
    pub wager: i128,
    /// Set by `submit_guess`; 0 until the player submits.
    pub guess: u32,
    pub status: GameStatus,
    /// The revealed secret number; populated only after `resolve_game`.
    pub secret: u32,
    /// Token payout sent to the player on a win; 0 on a loss or before resolution.
    pub payout: i128,
}

/// Storage key discriminants.
#[contracttype]
pub enum DataKey {
    // --- instance() keys: contract-level config ---
    Admin,
    RngContract,
    PrizePoolContract,
    BalanceContract,
    MinWager,
    MaxWager,
    HouseEdgeBps,
    // --- persistent() keys: per-game data ---
    Game(u64),
}

// ---------------------------------------------------------------------------
// Events
// ---------------------------------------------------------------------------

#[contractevent]
pub struct GameStarted {
    #[topic]
    pub game_id: u64,
    #[topic]
    pub player: Address,
    pub min: u32,
    pub max: u32,
    pub wager: i128,
}

#[contractevent]
pub struct GuessSubmitted {
    #[topic]
    pub game_id: u64,
    #[topic]
    pub player: Address,
    pub guess: u32,
}

#[contractevent]
pub struct GameResolved {
    #[topic]
    pub game_id: u64,
    #[topic]
    pub player: Address,
    pub guess: u32,
    pub secret: u32,
    pub won: bool,
    pub payout: i128,
}

// ---------------------------------------------------------------------------
// Contract
// ---------------------------------------------------------------------------

#[contract]
pub struct NumberGuess;

#[contractimpl]
impl NumberGuess {
    // -----------------------------------------------------------------------
    // init
    // -----------------------------------------------------------------------

    /// Initialize the contract. May only be called once.
    ///
    /// - `rng_contract`: address of the deployed Random Generator contract.
    /// - `prize_pool_contract`: reserved for future prize-pool integration.
    /// - `balance_contract`: the SEP-41 token used for wagers and payouts.
    /// - `min_wager` / `max_wager`: inclusive wager bounds enforced in
    ///   `start_game`.
    /// - `house_edge_bps`: house take in basis points (e.g. 250 = 2.5 %).
    pub fn init(
        env: Env,
        admin: Address,
        rng_contract: Address,
        prize_pool_contract: Address,
        balance_contract: Address,
        min_wager: i128,
        max_wager: i128,
        house_edge_bps: i128,
    ) -> Result<(), Error> {
        if env.storage().instance().has(&DataKey::Admin) {
            return Err(Error::AlreadyInitialized);
        }

        admin.require_auth();

        if min_wager <= 0 || max_wager < min_wager {
            return Err(Error::InvalidAmount);
        }
        if !(0..BASIS_POINTS_DIVISOR).contains(&house_edge_bps) {
            return Err(Error::InvalidAmount);
        }

        env.storage().instance().set(&DataKey::Admin, &admin);
        env.storage()
            .instance()
            .set(&DataKey::RngContract, &rng_contract);
        env.storage()
            .instance()
            .set(&DataKey::PrizePoolContract, &prize_pool_contract);
        env.storage()
            .instance()
            .set(&DataKey::BalanceContract, &balance_contract);
        env.storage().instance().set(&DataKey::MinWager, &min_wager);
        env.storage().instance().set(&DataKey::MaxWager, &max_wager);
        env.storage()
            .instance()
            .set(&DataKey::HouseEdgeBps, &house_edge_bps);

        Ok(())
    }

    // -----------------------------------------------------------------------
    // start_game
    // -----------------------------------------------------------------------

    /// Start a new number-guess game.
    ///
    /// The player selects a range `[min, max]` and places a `wager`.  Tokens
    /// are transferred from the player to this contract immediately.  A
    /// randomness request is submitted to the RNG contract using the
    /// `game_id` as the request identifier, so `game_id` must be globally
    /// unique across the RNG contract's request space.
    ///
    /// `game_id` is caller-provided and must not collide with any existing
    /// pending or fulfilled RNG request.
    pub fn start_game(
        env: Env,
        player: Address,
        min: u32,
        max: u32,
        wager: i128,
        game_id: u64,
    ) -> Result<(), Error> {
        require_initialized(&env)?;
        player.require_auth();

        // Range validation.
        if min >= max {
            return Err(Error::InvalidRange);
        }
        let range_size = (max - min).checked_add(1).ok_or(Error::Overflow)?;
        if range_size > MAX_RANGE_SIZE {
            return Err(Error::InvalidRange);
        }

        // Wager bounds.
        if wager <= 0 {
            return Err(Error::InvalidAmount);
        }
        let min_wager: i128 = env.storage().instance().get(&DataKey::MinWager).unwrap();
        let max_wager: i128 = env.storage().instance().get(&DataKey::MaxWager).unwrap();
        if wager < min_wager {
            return Err(Error::WagerTooLow);
        }
        if wager > max_wager {
            return Err(Error::WagerTooHigh);
        }

        // Duplicate game guard.
        let game_key = DataKey::Game(game_id);
        if env.storage().persistent().has(&game_key) {
            return Err(Error::GameAlreadyExists);
        }

        // Transfer wager from player to this contract.
        let token: Address = env
            .storage()
            .instance()
            .get(&DataKey::BalanceContract)
            .unwrap();
        TokenClient::new(&env, &token).transfer(&player, env.current_contract_address(), &wager);

        // Request randomness: result in [0, range_size).
        let rng_addr: Address = env.storage().instance().get(&DataKey::RngContract).unwrap();
        RandomGeneratorClient::new(&env, &rng_addr).request_random(
            &env.current_contract_address(),
            &game_id,
            &(range_size as u64),
        );

        // Persist initial game state.
        let game = Game {
            player: player.clone(),
            min,
            max,
            wager,
            guess: 0,
            status: GameStatus::Open,
            secret: 0,
            payout: 0,
        };
        env.storage().persistent().set(&game_key, &game);
        env.storage().persistent().extend_ttl(
            &game_key,
            PERSISTENT_BUMP_LEDGERS,
            PERSISTENT_BUMP_LEDGERS,
        );

        GameStarted {
            game_id,
            player,
            min,
            max,
            wager,
        }
        .publish(&env);

        Ok(())
    }

    // -----------------------------------------------------------------------
    // submit_guess
    // -----------------------------------------------------------------------

    /// Lock in the player's guess for an open game.
    ///
    /// Authorization is required from `game.player` — only the player who
    /// started the game can submit their guess.  The guess must lie within the
    /// `[min, max]` range declared in `start_game`.
    ///
    /// The guess must be submitted while the RNG request is still pending so
    /// that the oracle cannot choose a server seed after observing the guess.
    pub fn submit_guess(env: Env, game_id: u64, guess: u32) -> Result<(), Error> {
        require_initialized(&env)?;

        let game_key = DataKey::Game(game_id);
        let mut game: Game = env
            .storage()
            .persistent()
            .get(&game_key)
            .ok_or(Error::GameNotFound)?;

        if game.status != GameStatus::Open {
            if game.status == GameStatus::Guessed {
                return Err(Error::AlreadyGuessed);
            }
            return Err(Error::GameNotOpen);
        }

        // Only the player who started this game may set the guess.
        game.player.require_auth();

        if guess < game.min || guess > game.max {
            return Err(Error::GuessOutOfRange);
        }

        game.guess = guess;
        game.status = GameStatus::Guessed;
        env.storage().persistent().set(&game_key, &game);
        env.storage().persistent().extend_ttl(
            &game_key,
            PERSISTENT_BUMP_LEDGERS,
            PERSISTENT_BUMP_LEDGERS,
        );

        GuessSubmitted {
            game_id,
            player: game.player,
            guess,
        }
        .publish(&env);

        Ok(())
    }

    // -----------------------------------------------------------------------
    // resolve_game
    // -----------------------------------------------------------------------

    /// Resolve a game after the oracle has fulfilled the RNG request.
    ///
    /// No authorization required — the outcome is fully deterministic from
    /// on-chain data once the RNG is fulfilled.  The secret number is derived
    /// as `min + (rng_result % range_size)` where `rng_result` is the value
    /// stored by the RNG contract.
    ///
    /// Payout state is written before any token transfer to prevent reentrancy.
    pub fn resolve_game(env: Env, game_id: u64) -> Result<(), Error> {
        require_initialized(&env)?;

        let game_key = DataKey::Game(game_id);
        let mut game: Game = env
            .storage()
            .persistent()
            .get(&game_key)
            .ok_or(Error::GameNotFound)?;

        match game.status {
            GameStatus::Open => return Err(Error::GuessNotSubmitted),
            GameStatus::Won | GameStatus::Lost => return Err(Error::GameAlreadyResolved),
            GameStatus::Guessed => {}
        }

        // Fetch fulfilled RNG entry.
        let rng_addr: Address = env.storage().instance().get(&DataKey::RngContract).unwrap();
        let rng_client = RandomGeneratorClient::new(&env, &rng_addr);
        let rng_entry = match rng_client.try_get_result(&game_id) {
            Ok(Ok(e)) => e,
            _ => return Err(Error::RngNotFulfilled),
        };

        let range_size = (game.max - game.min + 1) as u64;
        let secret = game.min + (rng_entry.result % range_size) as u32;

        let won = game.guess == secret;

        let mut payout = 0i128;
        if won {
            let house_edge_bps: i128 = env
                .storage()
                .instance()
                .get(&DataKey::HouseEdgeBps)
                .unwrap();
            let gross_payout = game
                .wager
                .checked_mul(range_size as i128)
                .ok_or(Error::Overflow)?;
            let fee = gross_payout
                .checked_mul(house_edge_bps)
                .and_then(|v| v.checked_div(BASIS_POINTS_DIVISOR))
                .ok_or(Error::Overflow)?;
            payout = gross_payout.checked_sub(fee).ok_or(Error::Overflow)?;
        }

        // Update state before any external transfer (reentrancy guard).
        game.secret = secret;
        game.payout = payout;
        game.status = if won {
            GameStatus::Won
        } else {
            GameStatus::Lost
        };
        env.storage().persistent().set(&game_key, &game);
        env.storage().persistent().extend_ttl(
            &game_key,
            PERSISTENT_BUMP_LEDGERS,
            PERSISTENT_BUMP_LEDGERS,
        );

        if won {
            // TODO: Route payout through prize_pool_contract once it is
            // implemented.  Direct token transfer used in the interim.
            let token: Address = env
                .storage()
                .instance()
                .get(&DataKey::BalanceContract)
                .unwrap();
            TokenClient::new(&env, &token).transfer(
                &env.current_contract_address(),
                &game.player,
                &payout,
            );
        }

        GameResolved {
            game_id,
            player: game.player,
            guess: game.guess,
            secret,
            won,
            payout,
        }
        .publish(&env);

        Ok(())
    }

    // -----------------------------------------------------------------------
    // get_game
    // -----------------------------------------------------------------------

    /// Return the full game state, or `GameNotFound` if the id is unknown.
    pub fn get_game(env: Env, game_id: u64) -> Result<Game, Error> {
        env.storage()
            .persistent()
            .get(&DataKey::Game(game_id))
            .ok_or(Error::GameNotFound)
    }
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

fn require_initialized(env: &Env) -> Result<(), Error> {
    if !env.storage().instance().has(&DataKey::Admin) {
        return Err(Error::NotInitialized);
    }
    Ok(())
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod test;
